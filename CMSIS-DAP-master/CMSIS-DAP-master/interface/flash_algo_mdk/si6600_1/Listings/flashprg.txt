; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --debug -c --asm --interleave -o.\objects\flashprg.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\flashprg.d --cpu=Cortex-M0+ --apcs=interwork//ropi/rwpi -O0 -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.1\CMSIS\Include -IC:\Keil_v5\ARM\PACK\ARM\CMSIS\4.1.1 -DFLASH_MEM -DSTM32F10x_512 --omf_browse=.\objects\flashprg.crf FlashPrg.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  Init PROC
;;;94     
;;;95     int Init (unsigned long adr, unsigned long clk, unsigned long fnc) {
000000  4603              MOV      r3,r0
;;;96     
;;;97     //  base_adr = adr & ~(BANK1_SIZE - 1);          // Align to Size Boundary
;;;98     //
;;;99     //  // Zero Wait State
;;;100    //  FLASH->ACR  = 0x00000000;
;;;101    //
;;;102    //  // Unlock Flash    
;;;103    //  FLASH->KEYR  = FLASH_KEY1;
;;;104    //  FLASH->KEYR  = FLASH_KEY2;
;;;105    //#ifdef STM32F10x_1024
;;;106    //  FLASH->KEYR2 = FLASH_KEY1;                    // Flash bank 2
;;;107    //  FLASH->KEYR2 = FLASH_KEY2;
;;;108    //#endif
;;;109    //
;;;110    //  // Test if IWDG is running (IWDG in HW mode)
;;;111    //  if ((FLASH->OBR & 0x04) == 0x00) {
;;;112    //    // Set IWDG time out to ~32.768 second
;;;113    //    IWDG->KR  = 0x5555;                         // Enable write access to IWDG_PR and IWDG_RLR     
;;;114    //    IWDG->PR  = 0x06;                           // Set prescaler to 256  
;;;115    //    IWDG->RLR = 4095;                           // Set reload value to 4095
;;;116    //  }
;;;117    
;;;118      return (0);
000002  2000              MOVS     r0,#0
;;;119    }
000004  4770              BX       lr
;;;120    
                          ENDP

                  UnInit PROC
;;;122    
;;;123    int UnInit (unsigned long fnc) {
000006  4601              MOV      r1,r0
;;;124    //
;;;125    //  // Lock Flash
;;;126    //  FLASH->CR  |=  FLASH_LOCK;
;;;127    //#ifdef STM32F10x_1024
;;;128    //  FLASH->CR2 |=  FLASH_LOCK;                    // Flash bank 2
;;;129    //#endif
;;;130    //
;;;131    //  return (0);
;;;132    //}
;;;133    //#endif
;;;134    //
;;;135    //#ifdef FLASH_OPT
;;;136    //int UnInit (unsigned long fnc) {
;;;137    //
;;;138    //  // Lock Flash & Option Bytes
;;;139    //  FLASH->CR &= ~FLASH_OPTWRE;
;;;140    //  FLASH->CR |=  FLASH_LOCK;
;;;141    
;;;142      return (0);
000008  2000              MOVS     r0,#0
;;;143    }
00000a  4770              BX       lr
;;;144    
                          ENDP

                  EraseChip PROC
;;;150     */
;;;151    int EraseChip (void) {
00000c  2003              MOVS     r0,#3
;;;152    (*(volatile unsigned int *)(0x40020020)) = 0x03;
00000e  491c              LDR      r1,|L1.128|
000010  6208              STR      r0,[r1,#0x20]
;;;153    
;;;154    (*(volatile unsigned int *)(0x00000000)) = 0x66000001;
000012  481c              LDR      r0,|L1.132|
000014  2100              MOVS     r1,#0
000016  6008              STR      r0,[r1,#0]
;;;155    
;;;156    /*(*(volatile unsigned int *)(0x40012C00+0x18)) = 0x00;	
;;;157    (*(volatile unsigned int *)(0x40012C00+0x04)) = 0x00;
;;;158    (*(volatile unsigned int *)(0x40012C00+0x00)) = 0x00;
;;;159    (*(volatile unsigned int *)(0x40012C00+0x00)) = 0x02;*/	
;;;160    //	(*(volatile unsigned int *)(0x20000600)) = 0x00;	
;;;161    //(*(volatile unsigned int *)(0x20000604)) = 0x04;
;;;162    
;;;163    
;;;164    
;;;165    
;;;166      return (0);                                   // Done
000018  2000              MOVS     r0,#0
;;;167    }
00001a  4770              BX       lr
;;;168    
                          ENDP

                  EraseSector PROC
;;;179    #ifdef FLASH_MEM
;;;180    int EraseSector (unsigned long adr) {
00001c  4601              MOV      r1,r0
;;;181    
;;;182    #ifdef STM32F10x_1024
;;;183      if (adr < (base_adr + BANK1_SIZE)) {          // Flash bank 2
;;;184    #endif
;;;185        FLASH->CR  |=  FLASH_PER;                   // Page Erase Enabled 
00001e  2000              MOVS     r0,#0
000020  6900              LDR      r0,[r0,#0x10]
000022  2202              MOVS     r2,#2
000024  4310              ORRS     r0,r0,r2
000026  2200              MOVS     r2,#0
000028  6110              STR      r0,[r2,#0x10]
;;;186        FLASH->AR   =  adr;                         // Page Address
00002a  2000              MOVS     r0,#0
00002c  6141              STR      r1,[r0,#0x14]
;;;187        FLASH->CR  |=  FLASH_STRT;                  // Start Erase
00002e  6900              LDR      r0,[r0,#0x10]
000030  2240              MOVS     r2,#0x40
000032  4310              ORRS     r0,r0,r2
000034  2200              MOVS     r2,#0
000036  6110              STR      r0,[r2,#0x10]
;;;188    
;;;189        while (FLASH->SR  & FLASH_BSY) {
000038  e002              B        |L1.64|
                  |L1.58|
;;;190          IWDG->KR = 0xAAAA;                        // Reload IWDG
00003a  4813              LDR      r0,|L1.136|
00003c  4a13              LDR      r2,|L1.140|
00003e  6010              STR      r0,[r2,#0]
                  |L1.64|
000040  2000              MOVS     r0,#0                 ;189
000042  68c0              LDR      r0,[r0,#0xc]          ;189
000044  07c0              LSLS     r0,r0,#31             ;189
000046  0fc0              LSRS     r0,r0,#31             ;189
000048  2800              CMP      r0,#0                 ;189
00004a  d1f6              BNE      |L1.58|
;;;191        }
;;;192    
;;;193        FLASH->CR  &= ~FLASH_PER;                   // Page Erase Disabled 
00004c  6900              LDR      r0,[r0,#0x10]
00004e  2202              MOVS     r2,#2
000050  4390              BICS     r0,r0,r2
000052  2200              MOVS     r2,#0
000054  6110              STR      r0,[r2,#0x10]
;;;194    #ifdef STM32F10x_1024
;;;195      }
;;;196      else {                                        // Flash bank 2
;;;197        FLASH->CR2 |=  FLASH_PER;
;;;198        FLASH->AR2  =  adr;
;;;199        FLASH->CR2 |=  FLASH_STRT;
;;;200    
;;;201        while (FLASH->SR2 & FLASH_BSY) {
;;;202          IWDG->KR = 0xAAAA;
;;;203        }
;;;204    
;;;205        FLASH->CR2 &= ~FLASH_PER;
;;;206      }
;;;207    #endif
;;;208    
;;;209      return (0);                                   // Done
000056  2000              MOVS     r0,#0
;;;210    }
000058  4770              BX       lr
;;;211    #endif
                          ENDP

                  BlankCheck PROC
;;;223    
;;;224    int BlankCheck (unsigned long adr, unsigned long sz, unsigned char pat) {
00005a  4603              MOV      r3,r0
;;;225      return (1);                                   // Always Force Erase
00005c  2001              MOVS     r0,#1
;;;226    }
00005e  4770              BX       lr
;;;227    
                          ENDP

                  ProgramPage PROC
;;;237    
;;;238    int ProgramPage (unsigned long adr, unsigned long sz, unsigned char *buf)
000060  b510              PUSH     {r4,lr}
;;;239    {
000062  4603              MOV      r3,r0
;;;240      //int j;
;;;241    
;;;242      (*(volatile unsigned int *)(0x40020020)) = 0x01;
000064  2001              MOVS     r0,#1
000066  4c06              LDR      r4,|L1.128|
000068  6220              STR      r0,[r4,#0x20]
;;;243     
;;;244      /*for(j=0;j<sz;)//256word
;;;245    	{ 
;;;246    	   (*(volatile unsigned int *)(adr+j))=*((unsigned int *)buf);
;;;247    	   buf=buf+4;
;;;248    	   j=j+4;
;;;249    	}*/
;;;250      while (sz) 
00006a  e004              B        |L1.118|
                  |L1.108|
;;;251       {
;;;252    
;;;253        //FLASH->CR |=  FLASH_OPTPG;                  // Option Byte Programming Enabled
;;;254    
;;;255        (*(volatile unsigned int *)(adr))=*((unsigned int *)buf);
00006c  6810              LDR      r0,[r2,#0]
00006e  6018              STR      r0,[r3,#0]
;;;256    	adr += 4;
000070  1d1b              ADDS     r3,r3,#4
;;;257        buf += 4;
000072  1d12              ADDS     r2,r2,#4
;;;258        sz  -= 4;
000074  1f09              SUBS     r1,r1,#4
                  |L1.118|
000076  2900              CMP      r1,#0                 ;250
000078  d1f8              BNE      |L1.108|
;;;259    	}    
;;;260      return (0);                                   // Done
00007a  2000              MOVS     r0,#0
;;;261    }
00007c  bd10              POP      {r4,pc}
;;;262    
                          ENDP

00007e  0000              DCW      0x0000
                  |L1.128|
                          DCD      0x40020000
                  |L1.132|
                          DCD      0x66000001
                  |L1.136|
                          DCD      0x0000aaaa
                  |L1.140|
                          DCD      0x40003000

                          AREA ||.data||, DATA, ALIGN=2

                  base_adr
                          DCD      0x00000000
